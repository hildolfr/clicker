<!-- Generated by SpecStory -->

# Beep Style Reliability Issues (2025-05-21 10:16:18)

_**User**_

the two beep styles are indistinguishable, and it feels unreliable when toggling , laggy, like a leaky program. check it over thoroughly please.

---

_**Assistant**_



---

I'll check the codebase to identify the issues with beeps and toggle performance. Let's first look at the directory structure.

---

<details>
            <summary>Listed current directory ‚Ä¢ **11** results</summary>
        
| Name |
|-------|
| üìÑ `main.py` |
| üìÑ `clicker.log` |
| üìÑ `settings.json` |
| üìÑ `keystrokes.txt` |
| üìÅ `.git` |
| üìÑ `README.md` |
| üìÑ `icon.ico` |
| üìÑ `icon.png` |
| üìÑ `logo.png` |
| üìÑ `refactor.txt` |
| üìÑ `requirements.txt` |

</details>

---

Now I'll check the main.py file to understand how the beep and toggle functionality are implemented:

---

Read file: main.py

---

Let's look at the rest of the main.py file, particularly focusing on the beep functionality and toggle mechanism:

---

Read file: main.py

---

Now let's look at the notification overlay implementation and the final part of the code to understand the toggle mechanism better:

---

Read file: main.py

---

Based on my examination of the code, I've identified several issues that might be causing the problems you're experiencing with the beep styles being indistinguishable and the toggle functionality feeling unreliable/laggy:

Let's fix these issues:

---

```diff
      """Play a system beep sound the specified number of times."""
      try:
-         for _ in range(count):
-             winsound.Beep(1000, 200)  # 1000 Hz for 200ms
-             time.sleep(0.1)  # Small pause between beeps
+         if count == 1:
+             # OFF beep - lower pitch, shorter duration
+             winsound.Beep(800, 150)
+         else:
+             # ON beep - two distinct higher pitches with a gap
+             winsound.Beep(1200, 150)
+             time.sleep(0.1)
+             winsound.Beep(1500, 150)
      except Exception as e:
          logging.error(f"Error playing beep: {e}")
```

```diff
      with lock:
          active = running_flag['active']
-     if active:
-         stop_automation()
-         tray.setToolTip("Clicker: OFF")
-         # Play 1 beep for OFF
-         play_beep(1)
-     else:
+         # Toggle the state immediately to prevent multiple toggles
+         running_flag['active'] = not active
+     
+     # Use a separate thread for beeps to avoid UI lag
+     def toggle_action():
+         if not active:
+             # We're turning ON
+             tray.setToolTip("Clicker: ON")
+             # Play 2 beeps for ON
+             play_beep(2)
+         else:
+             # We're turning OFF
+             tray.setToolTip("Clicker: OFF")
+             # Play 1 beep for OFF
+             play_beep(1)
+             
+     # Run toggle action in a separate thread to prevent UI lag
+     toggle_thread = threading.Thread(target=toggle_action)
+     toggle_thread.daemon = True
+     toggle_thread.start()
+     
+     # Start or stop automation based on the new state
+     if not active:
          start_automation()
-         tray.setToolTip("Clicker: ON")
-         # Play 2 beeps for ON
-         play_beep(2)
+     else:
+         stop_automation()
  
  def start_automation():
```

---

Now let's fix the potential memory leak and lag in the automation worker function:

---

```diff
              logging.debug(f"Scheduled keystroke {key_str} to start at {initial_time - now:.2f}s from now")
      
-     while not exit_event.is_set():  # Check the exit event
+     # Keep schedule size manageable
+     max_schedule_size = len(keystrokes) * 2
+     check_interval = 0.01  # Check more frequently for better responsiveness
+     
+     while not exit_event.is_set():
          with lock:
              active = running_flag['active']
+         
          if not active or not schedule:
-             # Check exit event every 100ms when idle
-             if exit_event.wait(0.1):
+             # Check exit event frequently when idle for better responsiveness
+             if exit_event.wait(check_interval):
                  break
              continue
          
-         next_fire, idx, key_str, delay = heapq.heappop(schedule)
-         wait_time = max(0, next_fire - time.time())
-         if wait_time > 0:
-             # Wait but check for exit event periodically
-             if exit_event.wait(wait_time):
+         current_time = time.time()
+         next_fire, idx, key_str, delay = schedule[0]  # Peek without popping
+         
+         wait_time = max(0, next_fire - current_time)
+         if wait_time > check_interval:
+             # Wait but check for exit event frequently
+             if exit_event.wait(check_interval):
                  break
+             continue
+         
+         # Now we can pop the next item as we're going to process it
+         heapq.heappop(schedule)
          
          with lock:
```

```diff
              else:
                  send_key_combination([], key)
+                 
+             # Reschedule only if we're still active
+             with lock:
+                 if running_flag['active'] and not exit_event.is_set():
+                     next_time = current_time + delay
+                     heapq.heappush(schedule, (next_time, idx, key_str, delay))
+                     
+                     # Limit schedule size to prevent memory growth
+                     if len(schedule) > max_schedule_size:
+                         schedule = schedule[:max_schedule_size]
+                         heapq.heapify(schedule)
+                         
          except Exception as e:
              logging.error(f"Error processing keystroke {key_str}: {e}")
-         
-         with lock:
-             heapq.heappush(schedule, (time.time() + delay, idx, key_str, delay))
  
  def toggle():
```

---

Finally, let's improve the graceful shutdown to ensure proper cleanup and prevent hanging issues:

---

```diff
      logging.debug("Exit event set")
      
+     # Hide tray icon immediately to provide visual feedback
+     if tray:
+         tray.hide()
+     
      # Stop automation thread
      stop_automation()
      logging.debug("Automation stopped")
      
+     # Join any threads with timeout to prevent hanging
+     if thread.get('obj') and thread['obj'].is_alive():
+         try:
+             thread['obj'].join(timeout=0.5)  # Short timeout
+             logging.debug("Automation thread joined")
+         except Exception as e:
+             logging.error(f"Error joining automation thread: {e}")
+     
      # Stop watchdog observer
      if observer:
```

```diff
              observer.stop()
              # Join with timeout to avoid hanging
-             observer.join(timeout=1.0)
+             observer.join(timeout=0.5)
              logging.debug("Observer joined")
          except Exception as e:
```

```diff
      logging.debug("All resources cleaned up, exiting application")
      
-     # Wait a short time to ensure all resources are properly released
-     time.sleep(0.1)
-     
-     # Quit the application
+     # Exit quickly without waiting
      if app:
-         app.quit()  # Use standard app.quit() for a graceful exit
+         QtCore.QTimer.singleShot(100, app.quit)  # Use a shorter timeout
      
-     # If we're still running after 1 second, force exit
-     QtCore.QTimer.singleShot(1000, lambda: os._exit(0))
+     # Force exit after a short timeout if app is still running
+     QtCore.QTimer.singleShot(500, lambda: os._exit(0))
  
  def is_admin():
```

---

Now let's improve the rebind_hotkey function to be more robust:

---

```diff
          try:
              keyboard.remove_hotkey(hotkey_ref['key'])
-         except Exception:
-             pass
-     
-     try:
-         hotkey_ref['key'] = keyboard.add_hotkey(toggle_key, toggle)
+             hotkey_ref['key'] = None
+         except Exception as e:
+             logging.error(f"Failed to remove hotkey: {e}")
+     
+     # Clean up any lingering keyboard hooks before adding new ones
+     try:
+         keyboard.unhook_all()
+     except Exception as e:
+         logging.error(f"Failed to unhook keyboards: {e}")
+     
+     # Small delay to ensure cleanup
+     time.sleep(0.1)
+     
+     try:
+         # Using a simpler direct approach for binding hotkey
+         hotkey_ref['key'] = keyboard.add_hotkey(toggle_key, toggle, suppress=False)
          logging.info(f"Hotkey bound to '{toggle_key}'")
      except Exception as e:
```

---

Let's also improve our key event sending mechanism to be more reliable:

---

```diff
      try:
          flags = KEYEVENTF_KEYUP if is_key_up else 0
-         ctypes.windll.user32.keybd_event(
-             wintypes.BYTE(vk_code),
-             wintypes.BYTE(0),
-             wintypes.DWORD(flags),
-             wintypes.DWORD(0)
-         )
-         time.sleep(0.01)
+         
+         # For better reliability, use the SendInput API instead of keybd_event
+         extra = ctypes.c_ulong(0)
+         ii_ = INPUT()
+         ii_.type = INPUT_KEYBOARD
+         ii_.ki.wVk = wintypes.WORD(vk_code)
+         ii_.ki.wScan = wintypes.WORD(0)
+         ii_.ki.dwFlags = wintypes.DWORD(flags)
+         ii_.ki.time = wintypes.DWORD(0)
+         ii_.ki.dwExtraInfo = ctypes.pointer(extra)
+         
+         ctypes.windll.user32.SendInput(1, ctypes.byref(ii_), ctypes.sizeof(ii_))
+         
+         # Small delay for reliability
+         time.sleep(0.015)
          return True
      except Exception as e:
-         logging.error(f"Error in send_key_event: {e}")
+         logging.error(f"Error in send_key_event for key={vk_code}, up={is_key_up}: {e}")
          return False
  
```

```diff
              return False
          
-         # Press modifiers
+         # Press modifiers with increased delay for reliability
          for mod in modifiers:
              if mod == 'shift':
```

```diff
                  if not send_key_event(VK_MENU):
                      return False
+             time.sleep(0.03)  # Slightly longer delay between modifier keys
          
-         time.sleep(0.02)
-         
-         # Press and release the main key
+         # Press and release the main key with increased delays
+         time.sleep(0.03)
          if not send_key_event(vk_code):
              return False
-         time.sleep(0.02)
+         time.sleep(0.03)
          if not send_key_event(vk_code, is_key_up=True):
              return False
          
-         time.sleep(0.02)
+         time.sleep(0.03)
          
          # Release modifiers in reverse order
```

```diff
                  if not send_key_event(VK_MENU, is_key_up=True):
                      return False
+             time.sleep(0.03)  # Slightly longer delay between releasing modifiers
          
          return True
      except Exception as e:
-         logging.error(f"Error in send_key_combination: {e}")
+         logging.error(f"Error in send_key_combination for {modifiers}-{key}: {e}")
          return False
  
```

---

Let's now run the application to make sure all our changes fixed the issues:

---

Cancelled

---



---

_**User**_

this refactor is broken ; no beeps and no keyboard output

---

_**Assistant**_



---

I'll fix the issues with the broken beeps and keyboard output:

---

```diff
          flags = KEYEVENTF_KEYUP if is_key_up else 0
          
-         # For better reliability, use the SendInput API instead of keybd_event
-         extra = ctypes.c_ulong(0)
-         ii_ = INPUT()
-         ii_.type = INPUT_KEYBOARD
-         ii_.ki.wVk = wintypes.WORD(vk_code)
-         ii_.ki.wScan = wintypes.WORD(0)
-         ii_.ki.dwFlags = wintypes.DWORD(flags)
-         ii_.ki.time = wintypes.DWORD(0)
-         ii_.ki.dwExtraInfo = ctypes.pointer(extra)
-         
-         ctypes.windll.user32.SendInput(1, ctypes.byref(ii_), ctypes.sizeof(ii_))
+         # Revert to using keybd_event which was working before
+         ctypes.windll.user32.keybd_event(
+             vk_code,  # bVk
+             0,        # bScan
+             flags,    # dwFlags
+             0         # dwExtraInfo
+         )
          
-         # Small delay for reliability
-         time.sleep(0.015)
+         # Short delay for reliability
+         time.sleep(0.01)
          return True
      except Exception as e:
```

---

```diff
      try:
          if count == 1:
-             # OFF beep - lower pitch, shorter duration
-             winsound.Beep(800, 150)
+             # Simple beep for OFF
+             winsound.Beep(500, 200)
          else:
-             # ON beep - two distinct higher pitches with a gap
-             winsound.Beep(1200, 150)
+             # Double beep for ON
+             winsound.Beep(800, 200)
              time.sleep(0.1)
-             winsound.Beep(1500, 150)
+             winsound.Beep(800, 200)
      except Exception as e:
          logging.error(f"Error playing beep: {e}")
```

---

```diff
      with lock:
          active = running_flag['active']
-         # Toggle the state immediately to prevent multiple toggles
-         running_flag['active'] = not active
-     
-     # Use a separate thread for beeps to avoid UI lag
-     def toggle_action():
-         if not active:
-             # We're turning ON
-             tray.setToolTip("Clicker: ON")
-             # Play 2 beeps for ON
-             play_beep(2)
-         else:
-             # We're turning OFF
+     
+     if active:
+         stop_automation()
          tray.setToolTip("Clicker: OFF")
          # Play 1 beep for OFF
          play_beep(1)
-             
-     # Run toggle action in a separate thread to prevent UI lag
-     toggle_thread = threading.Thread(target=toggle_action)
-     toggle_thread.daemon = True
-     toggle_thread.start()
-     
-     # Start or stop automation based on the new state
-     if not active:
+     else:
          start_automation()
-     else:
-         stop_automation()
+         tray.setToolTip("Clicker: ON")
+         # Play 2 beeps for ON
+         play_beep(2)
  
  def start_automation():
```

---

```diff
              logging.debug(f"Scheduled keystroke {key_str} to start at {initial_time - now:.2f}s from now")
      
-     # Keep schedule size manageable
-     max_schedule_size = len(keystrokes) * 2
-     check_interval = 0.01  # Check more frequently for better responsiveness
-     
-     while not exit_event.is_set():
+     while not exit_event.is_set():  # Check the exit event
          with lock:
              active = running_flag['active']
-         
          if not active or not schedule:
-             # Check exit event frequently when idle for better responsiveness
-             if exit_event.wait(check_interval):
+             # Check exit event every 100ms when idle
+             if exit_event.wait(0.1):
                  break
              continue
          
-         current_time = time.time()
-         next_fire, idx, key_str, delay = schedule[0]  # Peek without popping
-         
-         wait_time = max(0, next_fire - current_time)
-         if wait_time > check_interval:
-             # Wait but check for exit event frequently
-             if exit_event.wait(check_interval):
+         next_fire, idx, key_str, delay = heapq.heappop(schedule)
+         wait_time = max(0, next_fire - time.time())
+         if wait_time > 0:
+             # Wait but check for exit event periodically
+             if exit_event.wait(wait_time):
                  break
-             continue
-         
-         # Now we can pop the next item as we're going to process it
-         heapq.heappop(schedule)
          
          with lock:
```

```diff
              else:
                  send_key_combination([], key)
-                 
-             # Reschedule only if we're still active
-             with lock:
-                 if running_flag['active'] and not exit_event.is_set():
-                     next_time = current_time + delay
-                     heapq.heappush(schedule, (next_time, idx, key_str, delay))
-                     
-                     # Limit schedule size to prevent memory growth
-                     if len(schedule) > max_schedule_size:
-                         schedule = schedule[:max_schedule_size]
-                         heapq.heapify(schedule)
-                         
          except Exception as e:
              logging.error(f"Error processing keystroke {key_str}: {e}")
+         
+         with lock:
+             heapq.heappush(schedule, (time.time() + delay, idx, key_str, delay))
  
  def toggle():
```

---

```diff
          try:
              keyboard.remove_hotkey(hotkey_ref['key'])
-             hotkey_ref['key'] = None
-         except Exception as e:
-             logging.error(f"Failed to remove hotkey: {e}")
-     
-     # Clean up any lingering keyboard hooks before adding new ones
-     try:
-         keyboard.unhook_all()
-     except Exception as e:
-         logging.error(f"Failed to unhook keyboards: {e}")
-     
-     # Small delay to ensure cleanup
-     time.sleep(0.1)
-     
-     try:
-         # Using a simpler direct approach for binding hotkey
-         hotkey_ref['key'] = keyboard.add_hotkey(toggle_key, toggle, suppress=False)
+         except Exception:
+             pass
+     
+     try:
+         hotkey_ref['key'] = keyboard.add_hotkey(toggle_key, toggle)
          logging.info(f"Hotkey bound to '{toggle_key}'")
      except Exception as e:
```

---

```diff
              return False
          
-         # Press modifiers with increased delay for reliability
+         # Press modifiers
          for mod in modifiers:
              if mod == 'shift':
```

```diff
                  if not send_key_event(VK_MENU):
                      return False
-             time.sleep(0.03)  # Slightly longer delay between modifier keys
+         
+         time.sleep(0.02)
          
-         # Press and release the main key with increased delays
-         time.sleep(0.03)
+         # Press and release the main key
          if not send_key_event(vk_code):
              return False
-         time.sleep(0.03)
+         time.sleep(0.02)
          if not send_key_event(vk_code, is_key_up=True):
              return False
          
-         time.sleep(0.03)
+         time.sleep(0.02)
          
          # Release modifiers in reverse order
```

```diff
                  if not send_key_event(VK_MENU, is_key_up=True):
                      return False
-             time.sleep(0.03)  # Slightly longer delay between releasing modifiers
          
          return True
      except Exception as e:
-         logging.error(f"Error in send_key_combination for {modifiers}-{key}: {e}")
+         logging.error(f"Error in send_key_combination: {e}")
          return False
  
```

---

```bash
python main.py
```

---

I've fixed the issues with the beeps and keyboard output by:

1. Reverted to the original `keybd_event` function for sending keystrokes instead of the `SendInput` API
2. Simplified the beep function to use more reliable frequencies and durations
3. Reverted the toggle function to its original simpler implementation
4. Restored the original automation worker function
5. Simplified the hotkey binding to its original implementation
6. Restored the original key combination function timing

These changes should restore functionality while maintaining slightly better audio feedback between the ON and OFF states. The application should now play beeps properly and correctly send keyboard output.

---

_**User**_

this version works but we're not hearing any beeps.

---

_**Assistant**_



---

Let's fix the beep issue by adding proper error handling and using more reliable beep settings:

---

```diff
      """Play a system beep sound the specified number of times."""
      try:
+         logging.debug(f"Attempting to play {count} beep(s)")
          if count == 1:
-             # Simple beep for OFF
-             winsound.Beep(500, 200)
+             # Lower frequency for OFF - more distinct
+             winsound.Beep(440, 300)  # A4 note, longer duration
+             logging.debug("Played OFF beep (440Hz)")
          else:
-             # Double beep for ON
-             winsound.Beep(800, 200)
+             # Higher frequency for ON
+             winsound.Beep(880, 200)  # A5 note
              time.sleep(0.1)
-             winsound.Beep(800, 200)
+             winsound.Beep(880, 200)  # Repeat same note
+             logging.debug("Played ON beeps (880Hz)")
      except Exception as e:
-         logging.error(f"Error playing beep: {e}")
+         logging.error(f"Error playing beep: {str(e)}")
+         # Try alternative beep method as fallback
+         try:
+             if sys.platform == 'win32':
+                 import ctypes
+                 MessageBeep = ctypes.windll.user32.MessageBeep
+                 MessageBeep(0xFFFFFFFF)  # Simple system beep
+                 logging.debug("Used MessageBeep fallback")
+         except Exception as e2:
+             logging.error(f"Fallback beep also failed: {str(e2)}")
  
  # --- File Validation and Autocreation ---
```

---

```bash
python main.py
```

---

Let's check the log file to see if there are any errors related to the beep functionality:

---

```bash
type clicker.log | Select-Object -Last 20
```

```
PS C:\Users\User\Documents\clicker> type clicker.log | Select-Object -Last 20
2025-05-21 10:39:33,482 - INFO - Hotkey bound to '~'
2025-05-21 10:39:39,212 - DEBUG - Scheduled keystroke S-2 to start at 0.00s from
 now
2025-05-21 10:39:39,216 - DEBUG - Scheduled keystroke C-5 to start at 2.00s from
 now
2025-05-21 10:39:39,216 - DEBUG - Scheduled keystroke 6 to start at 4.00s from n
ow
2025-05-21 10:39:39,216 - DEBUG - Processing keystroke: S-2 -> mods=['shift'], k
ey=2
2025-05-21 10:39:39,216 - DEBUG - Sending key combination: modifiers=['shift'],
key=2
2025-05-21 10:39:41,222 - DEBUG - Processing keystroke: C-5 -> mods=['ctrl'], ke
y=5
2025-05-21 10:39:41,222 - DEBUG - Sending key combination: modifiers=['ctrl'], k
ey=5
2025-05-21 10:39:43,225 - DEBUG - Processing keystroke: 6 -> mods=[], key=6
2025-05-21 10:39:43,225 - DEBUG - Sending key combination: modifiers=[], key=6
2025-05-21 10:39:54,628 - DEBUG - Starting graceful shutdown
2025-05-21 10:39:54,628 - DEBUG - Exit event set
2025-05-21 10:39:54,634 - DEBUG - Automation stopped
2025-05-21 10:39:54,634 - DEBUG - Stopping observer
2025-05-21 10:39:54,636 - DEBUG - Observer joined
2025-05-21 10:39:54,636 - DEBUG - Unhooking keyboard
2025-05-21 10:39:54,636 - DEBUG - Keyboard unhooked
2025-05-21 10:39:54,636 - DEBUG - Cleanup: Removing lockfile
2025-05-21 10:39:54,636 - DEBUG - All resources cleaned up, exiting application
PS C:\Users\User\Documents\clicker>

```

---

It looks like there are no beep-related logs in the recent logs. Let's modify the toggle function to ensure beeps are triggered and properly logged:

---

```diff
          active = running_flag['active']
      
+     logging.info(f"Toggle called, current state: {'ON' if active else 'OFF'}")
+     
      if active:
          stop_automation()
          tray.setToolTip("Clicker: OFF")
          # Play 1 beep for OFF
+         logging.info("About to play OFF beep")
          play_beep(1)
+         logging.info("OFF beep completed")
      else:
          start_automation()
          tray.setToolTip("Clicker: ON")
          # Play 2 beeps for ON
+         logging.info("About to play ON beeps")
          play_beep(2)
+         logging.info("ON beeps completed")
  
  def start_automation():
```

---

Let's try using a completely different approach for beeps:

---

```diff
      """Play a system beep sound the specified number of times."""
      try:
-         logging.debug(f"Attempting to play {count} beep(s)")
+         # Windows MB_OK sound (more reliable than winsound.Beep)
+         if sys.platform == 'win32':
+             MB_ICONINFORMATION = 0x00000040
+             MB_ICONEXCLAMATION = 0x00000030
+             
              if count == 1:
-             # Lower frequency for OFF - more distinct
-             winsound.Beep(440, 300)  # A4 note, longer duration
-             logging.debug("Played OFF beep (440Hz)")
+                 # OFF sound - information
+                 ctypes.windll.user32.MessageBeep(MB_ICONINFORMATION)
+                 logging.info("Played OFF beep using MessageBeep")
              else:
-             # Higher frequency for ON
-             winsound.Beep(880, 200)  # A5 note
-             time.sleep(0.1)
-             winsound.Beep(880, 200)  # Repeat same note
-             logging.debug("Played ON beeps (880Hz)")
+                 # ON sound - warning/exclamation (double beep)
+                 ctypes.windll.user32.MessageBeep(MB_ICONEXCLAMATION)
+                 logging.info("Played ON beep using MessageBeep")
      except Exception as e:
-         logging.error(f"Error playing beep: {str(e)}")
-         # Try alternative beep method as fallback
+         logging.error(f"Error playing MessageBeep: {str(e)}")
+         # Fall back to winsound as a last resort
          try:
-             if sys.platform == 'win32':
-                 import ctypes
-                 MessageBeep = ctypes.windll.user32.MessageBeep
-                 MessageBeep(0xFFFFFFFF)  # Simple system beep
-                 logging.debug("Used MessageBeep fallback")
+             if count == 1:
+                 winsound.Beep(440, 300)
+             else:
+                 winsound.Beep(880, 200)
+                 time.sleep(0.1)
+                 winsound.Beep(880, 200)
+             logging.info("Used winsound.Beep fallback")
          except Exception as e2:
-             logging.error(f"Fallback beep also failed: {str(e2)}")
+             logging.error(f"All beep methods failed: {str(e2)}")
  
  # --- File Validation and Autocreation ---
```

---

```bash
python main.py
```

---

Try another approach by adding a QSound-based beep method which might work better in a Qt application:

---

Cancelled

---

_**User**_

current version works but still only get one beep on toggle-off

---

_**Assistant**_



---

Let's modify the beep function to ensure we get two distinct beeps when toggling on:

---

```diff
      """Play a system beep sound the specified number of times."""
      try:
-         # Windows MB_OK sound (more reliable than winsound.Beep)
-         if sys.platform == 'win32':
-             MB_ICONINFORMATION = 0x00000040
-             MB_ICONEXCLAMATION = 0x00000030
-             
+         # Use standard system beep - directly call the appropriate number of times
          if count == 1:
-                 # OFF sound - information
-                 ctypes.windll.user32.MessageBeep(MB_ICONINFORMATION)
-                 logging.info("Played OFF beep using MessageBeep")
+             # Single beep for OFF
+             ctypes.windll.user32.MessageBeep(0xFFFFFFFF)  # Default system beep
+             logging.info("Played single OFF beep")
          else:
-                 # ON sound - warning/exclamation (double beep)
-                 ctypes.windll.user32.MessageBeep(MB_ICONEXCLAMATION)
-                 logging.info("Played ON beep using MessageBeep")
+             # Two beeps for ON - explicitly call twice
+             ctypes.windll.user32.MessageBeep(0xFFFFFFFF)  # First beep
+             time.sleep(0.3)  # Wait between beeps so they're distinct
+             ctypes.windll.user32.MessageBeep(0xFFFFFFFF)  # Second beep
+             logging.info("Played double ON beeps")
      except Exception as e:
          logging.error(f"Error playing MessageBeep: {str(e)}")
          # Fall back to winsound as a last resort
          try:
              if count == 1:
-                 winsound.Beep(440, 300)
+                 winsound.Beep(800, 200)  # Single beep
              else:
-                 winsound.Beep(880, 200)
-                 time.sleep(0.1)
-                 winsound.Beep(880, 200)
+                 winsound.Beep(800, 200)  # First beep
+                 time.sleep(0.3)  # Wait
+                 winsound.Beep(800, 200)  # Second beep
              logging.info("Used winsound.Beep fallback")
          except Exception as e2:
```

---

```bash
python main.py
```

---

Now the application should play two distinct beeps when toggling ON and a single beep when toggling OFF. 

I've updated the beep functionality to:

1. Use the direct system beep by calling MessageBeep the appropriate number of times
2. Added a longer delay (0.3 seconds) between beeps for the ON state to make them more distinguishable
3. Made sure the same beep sound is used for consistency
4. Maintained the winsound.Beep fallback with the same pattern in case MessageBeep fails

This approach should ensure you get:
- A single beep when toggling OFF
- Two clearly separated beeps when toggling ON

Try pressing your toggle key (~) to switch between ON and OFF states, and you should now hear two distinct beeps when turning ON.

---

